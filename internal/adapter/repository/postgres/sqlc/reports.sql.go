// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: reports.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const addAnonymousReportVote = `-- name: AddAnonymousReportVote :exec
INSERT INTO report_votes (report_id, anonymous_session_id, vote_type)
VALUES ($1, $2, $3)
ON CONFLICT (report_id, anonymous_session_id) DO UPDATE SET vote_type = EXCLUDED.vote_type, created_at = NOW()
`

type AddAnonymousReportVoteParams struct {
	ReportID           uuid.UUID     `json:"report_id"`
	AnonymousSessionID uuid.NullUUID `json:"anonymous_session_id"`
	VoteType           string        `json:"vote_type"`
}

func (q *Queries) AddAnonymousReportVote(ctx context.Context, arg AddAnonymousReportVoteParams) error {
	_, err := q.db.ExecContext(ctx, addAnonymousReportVote, arg.ReportID, arg.AnonymousSessionID, arg.VoteType)
	return err
}

const addUserReportVote = `-- name: AddUserReportVote :exec
INSERT INTO report_votes (report_id, user_id, vote_type)
VALUES ($1, $2, $3)
ON CONFLICT (report_id, user_id) DO UPDATE SET vote_type = EXCLUDED.vote_type, created_at = NOW()
`

type AddUserReportVoteParams struct {
	ReportID uuid.UUID     `json:"report_id"`
	UserID   uuid.NullUUID `json:"user_id"`
	VoteType string        `json:"vote_type"`
}

func (q *Queries) AddUserReportVote(ctx context.Context, arg AddUserReportVoteParams) error {
	_, err := q.db.ExecContext(ctx, addUserReportVote, arg.ReportID, arg.UserID, arg.VoteType)
	return err
}

const countReports = `-- name: CountReports :one
SELECT COUNT(*) FROM reports
WHERE ($1::text IS NULL OR status = $1::report_status) AND is_private = FALSE
`

func (q *Queries) CountReports(ctx context.Context, status sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, countReports, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createReport = `-- name: CreateReport :one
INSERT INTO reports (
    user_id, risk_type_id, risk_topic_id, description,
    latitude, longitude, province, municipality,
    neighborhood, address, image_url
) VALUES (
             $1, $2, $3, $4, $5,
             $6, $7, $8, $9, $10, $11
         )
RETURNING id
`

type CreateReportParams struct {
	UserID       uuid.UUID      `json:"user_id"`
	RiskTypeID   uuid.UUID      `json:"risk_type_id"`
	RiskTopicID  uuid.NullUUID  `json:"risk_topic_id"`
	Description  sql.NullString `json:"description"`
	Latitude     float64        `json:"latitude"`
	Longitude    float64        `json:"longitude"`
	Province     sql.NullString `json:"province"`
	Municipality sql.NullString `json:"municipality"`
	Neighborhood sql.NullString `json:"neighborhood"`
	Address      sql.NullString `json:"address"`
	ImageUrl     sql.NullString `json:"image_url"`
}

func (q *Queries) CreateReport(ctx context.Context, arg CreateReportParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createReport,
		arg.UserID,
		arg.RiskTypeID,
		arg.RiskTopicID,
		arg.Description,
		arg.Latitude,
		arg.Longitude,
		arg.Province,
		arg.Municipality,
		arg.Neighborhood,
		arg.Address,
		arg.ImageUrl,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createReportNotification = `-- name: CreateReportNotification :exec
INSERT INTO notifications (type, reference_id, user_id) VALUES ($1, $2, $3)
ON CONFLICT (type, reference_id, user_id) DO NOTHING
`

type CreateReportNotificationParams struct {
	Type        NotificationType `json:"type"`
	ReferenceID uuid.UUID        `json:"reference_id"`
	UserID      uuid.UUID        `json:"user_id"`
}

func (q *Queries) CreateReportNotification(ctx context.Context, arg CreateReportNotificationParams) error {
	_, err := q.db.ExecContext(ctx, createReportNotification, arg.Type, arg.ReferenceID, arg.UserID)
	return err
}

const deleteReport = `-- name: DeleteReport :exec
DELETE FROM reports WHERE id = $1
`

func (q *Queries) DeleteReport(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteReport, id)
	return err
}

const expireOldReports = `-- name: ExpireOldReports :exec
UPDATE reports
SET status = 'rejected', updated_at = NOW()
WHERE status = 'pending'
  AND expires_at IS NOT NULL
  AND expires_at < $1
`

func (q *Queries) ExpireOldReports(ctx context.Context, expiresAt sql.NullTime) error {
	_, err := q.db.ExecContext(ctx, expireOldReports, expiresAt)
	return err
}

const findDuplicateReports = `-- name: FindDuplicateReports :many
SELECT 
    r.id, r.user_id, r.risk_type_id, r.risk_topic_id, r.description, r.latitude, r.longitude, r.province, r.municipality, r.neighborhood, r.address, r.image_url, r.status, r.reviewed_by, r.resolved_at, r.verification_count, r.rejection_count, r.expires_at, r.is_private, r.created_at, r.updated_at,
    rt.name as risk_type_name,
    rt.icon_path as risk_type_icon_path,
    rtopic.name as risk_topic_name,
    rtopic.icon_path as risk_topic_icon_path
FROM reports r
LEFT JOIN risk_types rt ON r.risk_type_id = rt.id
LEFT JOIN risk_topics rtopic ON r.risk_topic_id = rtopic.id
WHERE r.risk_type_id = $1
  AND r.status = 'pending'
  AND r.is_private = FALSE
  AND rt.is_enabled = TRUE
  AND r.created_at > $2
  AND ST_DWithin(
    ST_MakePoint(r.longitude, r.latitude)::geography,
    ST_MakePoint($4, $3)::geography,
    $5
  )
ORDER BY r.created_at DESC
`

type FindDuplicateReportsParams struct {
	RiskTypeID    uuid.UUID    `json:"risk_type_id"`
	CreatedAt     sql.NullTime `json:"created_at"`
	StMakepoint   interface{}  `json:"st_makepoint"`
	StMakepoint_2 interface{}  `json:"st_makepoint_2"`
	StDwithin     interface{}  `json:"st_dwithin"`
}

type FindDuplicateReportsRow struct {
	ID                uuid.UUID      `json:"id"`
	UserID            uuid.UUID      `json:"user_id"`
	RiskTypeID        uuid.UUID      `json:"risk_type_id"`
	RiskTopicID       uuid.NullUUID  `json:"risk_topic_id"`
	Description       sql.NullString `json:"description"`
	Latitude          float64        `json:"latitude"`
	Longitude         float64        `json:"longitude"`
	Province          sql.NullString `json:"province"`
	Municipality      sql.NullString `json:"municipality"`
	Neighborhood      sql.NullString `json:"neighborhood"`
	Address           sql.NullString `json:"address"`
	ImageUrl          sql.NullString `json:"image_url"`
	Status            interface{}    `json:"status"`
	ReviewedBy        uuid.NullUUID  `json:"reviewed_by"`
	ResolvedAt        sql.NullTime   `json:"resolved_at"`
	VerificationCount sql.NullInt32  `json:"verification_count"`
	RejectionCount    sql.NullInt32  `json:"rejection_count"`
	ExpiresAt         sql.NullTime   `json:"expires_at"`
	IsPrivate         bool           `json:"is_private"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	RiskTypeName      sql.NullString `json:"risk_type_name"`
	RiskTypeIconPath  sql.NullString `json:"risk_type_icon_path"`
	RiskTopicName     sql.NullString `json:"risk_topic_name"`
	RiskTopicIconPath sql.NullString `json:"risk_topic_icon_path"`
}

func (q *Queries) FindDuplicateReports(ctx context.Context, arg FindDuplicateReportsParams) ([]FindDuplicateReportsRow, error) {
	rows, err := q.db.QueryContext(ctx, findDuplicateReports,
		arg.RiskTypeID,
		arg.CreatedAt,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.StDwithin,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FindDuplicateReportsRow{}
	for rows.Next() {
		var i FindDuplicateReportsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RiskTypeID,
			&i.RiskTopicID,
			&i.Description,
			&i.Latitude,
			&i.Longitude,
			&i.Province,
			&i.Municipality,
			&i.Neighborhood,
			&i.Address,
			&i.ImageUrl,
			&i.Status,
			&i.ReviewedBy,
			&i.ResolvedAt,
			&i.VerificationCount,
			&i.RejectionCount,
			&i.ExpiresAt,
			&i.IsPrivate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RiskTypeName,
			&i.RiskTypeIconPath,
			&i.RiskTopicName,
			&i.RiskTopicIconPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAnonymousVote = `-- name: GetAnonymousVote :one
SELECT id, report_id, user_id, anonymous_session_id, vote_type, created_at FROM report_votes WHERE report_id = $1 AND anonymous_session_id = $2
`

type GetAnonymousVoteParams struct {
	ReportID           uuid.UUID     `json:"report_id"`
	AnonymousSessionID uuid.NullUUID `json:"anonymous_session_id"`
}

func (q *Queries) GetAnonymousVote(ctx context.Context, arg GetAnonymousVoteParams) (ReportVote, error) {
	row := q.db.QueryRowContext(ctx, getAnonymousVote, arg.ReportID, arg.AnonymousSessionID)
	var i ReportVote
	err := row.Scan(
		&i.ID,
		&i.ReportID,
		&i.UserID,
		&i.AnonymousSessionID,
		&i.VoteType,
		&i.CreatedAt,
	)
	return i, err
}

const getReportByID = `-- name: GetReportByID :one
SELECT 
    r.id, r.user_id, r.risk_type_id, r.risk_topic_id, r.description, r.latitude, r.longitude, r.province, r.municipality, r.neighborhood, r.address, r.image_url, r.status, r.reviewed_by, r.resolved_at, r.verification_count, r.rejection_count, r.expires_at, r.is_private, r.created_at, r.updated_at,
    rt.name as risk_type_name,
    rt.icon_path as risk_type_icon_path,
    rtopic.name as risk_topic_name,
    rtopic.icon_path as risk_topic_icon_path
FROM reports r
LEFT JOIN risk_types rt ON r.risk_type_id = rt.id
LEFT JOIN risk_topics rtopic ON r.risk_topic_id = rtopic.id
WHERE r.id = $1 AND rt.is_enabled = TRUE
`

type GetReportByIDRow struct {
	ID                uuid.UUID      `json:"id"`
	UserID            uuid.UUID      `json:"user_id"`
	RiskTypeID        uuid.UUID      `json:"risk_type_id"`
	RiskTopicID       uuid.NullUUID  `json:"risk_topic_id"`
	Description       sql.NullString `json:"description"`
	Latitude          float64        `json:"latitude"`
	Longitude         float64        `json:"longitude"`
	Province          sql.NullString `json:"province"`
	Municipality      sql.NullString `json:"municipality"`
	Neighborhood      sql.NullString `json:"neighborhood"`
	Address           sql.NullString `json:"address"`
	ImageUrl          sql.NullString `json:"image_url"`
	Status            interface{}    `json:"status"`
	ReviewedBy        uuid.NullUUID  `json:"reviewed_by"`
	ResolvedAt        sql.NullTime   `json:"resolved_at"`
	VerificationCount sql.NullInt32  `json:"verification_count"`
	RejectionCount    sql.NullInt32  `json:"rejection_count"`
	ExpiresAt         sql.NullTime   `json:"expires_at"`
	IsPrivate         bool           `json:"is_private"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	RiskTypeName      sql.NullString `json:"risk_type_name"`
	RiskTypeIconPath  sql.NullString `json:"risk_type_icon_path"`
	RiskTopicName     sql.NullString `json:"risk_topic_name"`
	RiskTopicIconPath sql.NullString `json:"risk_topic_icon_path"`
}

func (q *Queries) GetReportByID(ctx context.Context, id uuid.UUID) (GetReportByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getReportByID, id)
	var i GetReportByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RiskTypeID,
		&i.RiskTopicID,
		&i.Description,
		&i.Latitude,
		&i.Longitude,
		&i.Province,
		&i.Municipality,
		&i.Neighborhood,
		&i.Address,
		&i.ImageUrl,
		&i.Status,
		&i.ReviewedBy,
		&i.ResolvedAt,
		&i.VerificationCount,
		&i.RejectionCount,
		&i.ExpiresAt,
		&i.IsPrivate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RiskTypeName,
		&i.RiskTypeIconPath,
		&i.RiskTopicName,
		&i.RiskTopicIconPath,
	)
	return i, err
}

const getUserVote = `-- name: GetUserVote :one
SELECT id, report_id, user_id, anonymous_session_id, vote_type, created_at FROM report_votes WHERE report_id = $1 AND user_id = $2
`

type GetUserVoteParams struct {
	ReportID uuid.UUID     `json:"report_id"`
	UserID   uuid.NullUUID `json:"user_id"`
}

func (q *Queries) GetUserVote(ctx context.Context, arg GetUserVoteParams) (ReportVote, error) {
	row := q.db.QueryRowContext(ctx, getUserVote, arg.ReportID, arg.UserID)
	var i ReportVote
	err := row.Scan(
		&i.ID,
		&i.ReportID,
		&i.UserID,
		&i.AnonymousSessionID,
		&i.VoteType,
		&i.CreatedAt,
	)
	return i, err
}

const incrementUserReportsSubmitted = `-- name: IncrementUserReportsSubmitted :exec
UPDATE users SET reports_submitted = reports_submitted + 1, updated_at = NOW() WHERE id = $1
`

func (q *Queries) IncrementUserReportsSubmitted(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, incrementUserReportsSubmitted, id)
	return err
}

const incrementUserReportsVerified = `-- name: IncrementUserReportsVerified :exec
UPDATE users SET reports_verified = reports_verified + 1, updated_at = NOW() WHERE id = $1
`

func (q *Queries) IncrementUserReportsVerified(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, incrementUserReportsVerified, id)
	return err
}

const listReportsByIDs = `-- name: ListReportsByIDs :many
SELECT
    r.id, r.user_id, r.risk_type_id, r.risk_topic_id, r.description,
    r.latitude, r.longitude, r.province, r.municipality, r.neighborhood,
    r.address, r.image_url, r.status, r.reviewed_by, r.resolved_at,
    r.verification_count, r.rejection_count, r.expires_at, r.is_private,
    r.created_at, r.updated_at,
    rt.name as risk_type_name,
    rt.icon_path as risk_type_icon_path,
    rtopic.name as risk_topic_name,
    rtopic.icon_path as risk_topic_icon_path
FROM reports r
LEFT JOIN risk_types rt ON r.risk_type_id = rt.id
LEFT JOIN risk_topics rtopic ON r.risk_topic_id = rtopic.id
WHERE r.id = ANY($1::uuid[]) AND r.is_private = FALSE AND rt.is_enabled = TRUE
ORDER BY r.created_at DESC
`

type ListReportsByIDsRow struct {
	ID                uuid.UUID      `json:"id"`
	UserID            uuid.UUID      `json:"user_id"`
	RiskTypeID        uuid.UUID      `json:"risk_type_id"`
	RiskTopicID       uuid.NullUUID  `json:"risk_topic_id"`
	Description       sql.NullString `json:"description"`
	Latitude          float64        `json:"latitude"`
	Longitude         float64        `json:"longitude"`
	Province          sql.NullString `json:"province"`
	Municipality      sql.NullString `json:"municipality"`
	Neighborhood      sql.NullString `json:"neighborhood"`
	Address           sql.NullString `json:"address"`
	ImageUrl          sql.NullString `json:"image_url"`
	Status            interface{}    `json:"status"`
	ReviewedBy        uuid.NullUUID  `json:"reviewed_by"`
	ResolvedAt        sql.NullTime   `json:"resolved_at"`
	VerificationCount sql.NullInt32  `json:"verification_count"`
	RejectionCount    sql.NullInt32  `json:"rejection_count"`
	ExpiresAt         sql.NullTime   `json:"expires_at"`
	IsPrivate         bool           `json:"is_private"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	RiskTypeName      sql.NullString `json:"risk_type_name"`
	RiskTypeIconPath  sql.NullString `json:"risk_type_icon_path"`
	RiskTopicName     sql.NullString `json:"risk_topic_name"`
	RiskTopicIconPath sql.NullString `json:"risk_topic_icon_path"`
}

func (q *Queries) ListReportsByIDs(ctx context.Context, dollar_1 []uuid.UUID) ([]ListReportsByIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, listReportsByIDs, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReportsByIDsRow{}
	for rows.Next() {
		var i ListReportsByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RiskTypeID,
			&i.RiskTopicID,
			&i.Description,
			&i.Latitude,
			&i.Longitude,
			&i.Province,
			&i.Municipality,
			&i.Neighborhood,
			&i.Address,
			&i.ImageUrl,
			&i.Status,
			&i.ReviewedBy,
			&i.ResolvedAt,
			&i.VerificationCount,
			&i.RejectionCount,
			&i.ExpiresAt,
			&i.IsPrivate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RiskTypeName,
			&i.RiskTypeIconPath,
			&i.RiskTopicName,
			&i.RiskTopicIconPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReportsByStatus = `-- name: ListReportsByStatus :many
SELECT 
    r.id, r.user_id, r.risk_type_id, r.risk_topic_id, r.description, r.latitude, r.longitude, r.province, r.municipality, r.neighborhood, r.address, r.image_url, r.status, r.reviewed_by, r.resolved_at, r.verification_count, r.rejection_count, r.expires_at, r.is_private, r.created_at, r.updated_at,
    rt.name as risk_type_name,
    rt.icon_path as risk_type_icon_path,
    rtopic.name as risk_topic_name,
    rtopic.icon_path as risk_topic_icon_path
FROM reports r
LEFT JOIN risk_types rt ON r.risk_type_id = rt.id
LEFT JOIN risk_topics rtopic ON r.risk_topic_id = rtopic.id
WHERE r.status = $1 AND r.is_private = FALSE AND rt.is_enabled = TRUE
ORDER BY r.created_at DESC
`

type ListReportsByStatusRow struct {
	ID                uuid.UUID      `json:"id"`
	UserID            uuid.UUID      `json:"user_id"`
	RiskTypeID        uuid.UUID      `json:"risk_type_id"`
	RiskTopicID       uuid.NullUUID  `json:"risk_topic_id"`
	Description       sql.NullString `json:"description"`
	Latitude          float64        `json:"latitude"`
	Longitude         float64        `json:"longitude"`
	Province          sql.NullString `json:"province"`
	Municipality      sql.NullString `json:"municipality"`
	Neighborhood      sql.NullString `json:"neighborhood"`
	Address           sql.NullString `json:"address"`
	ImageUrl          sql.NullString `json:"image_url"`
	Status            interface{}    `json:"status"`
	ReviewedBy        uuid.NullUUID  `json:"reviewed_by"`
	ResolvedAt        sql.NullTime   `json:"resolved_at"`
	VerificationCount sql.NullInt32  `json:"verification_count"`
	RejectionCount    sql.NullInt32  `json:"rejection_count"`
	ExpiresAt         sql.NullTime   `json:"expires_at"`
	IsPrivate         bool           `json:"is_private"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	RiskTypeName      sql.NullString `json:"risk_type_name"`
	RiskTypeIconPath  sql.NullString `json:"risk_type_icon_path"`
	RiskTopicName     sql.NullString `json:"risk_topic_name"`
	RiskTopicIconPath sql.NullString `json:"risk_topic_icon_path"`
}

func (q *Queries) ListReportsByStatus(ctx context.Context, status interface{}) ([]ListReportsByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, listReportsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReportsByStatusRow{}
	for rows.Next() {
		var i ListReportsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RiskTypeID,
			&i.RiskTopicID,
			&i.Description,
			&i.Latitude,
			&i.Longitude,
			&i.Province,
			&i.Municipality,
			&i.Neighborhood,
			&i.Address,
			&i.ImageUrl,
			&i.Status,
			&i.ReviewedBy,
			&i.ResolvedAt,
			&i.VerificationCount,
			&i.RejectionCount,
			&i.ExpiresAt,
			&i.IsPrivate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RiskTypeName,
			&i.RiskTypeIconPath,
			&i.RiskTopicName,
			&i.RiskTopicIconPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReportsByUser = `-- name: ListReportsByUser :many
SELECT 
    r.id, r.user_id, r.risk_type_id, r.risk_topic_id, r.description, r.latitude, r.longitude, r.province, r.municipality, r.neighborhood, r.address, r.image_url, r.status, r.reviewed_by, r.resolved_at, r.verification_count, r.rejection_count, r.expires_at, r.is_private, r.created_at, r.updated_at,
    rt.name as risk_type_name,
    rt.icon_path as risk_type_icon_path,
    rtopic.name as risk_topic_name,
    rtopic.icon_path as risk_topic_icon_path
FROM reports r
LEFT JOIN risk_types rt ON r.risk_type_id = rt.id
LEFT JOIN risk_topics rtopic ON r.risk_topic_id = rtopic.id
WHERE r.user_id = $1 
ORDER BY r.created_at DESC
`

type ListReportsByUserRow struct {
	ID                uuid.UUID      `json:"id"`
	UserID            uuid.UUID      `json:"user_id"`
	RiskTypeID        uuid.UUID      `json:"risk_type_id"`
	RiskTopicID       uuid.NullUUID  `json:"risk_topic_id"`
	Description       sql.NullString `json:"description"`
	Latitude          float64        `json:"latitude"`
	Longitude         float64        `json:"longitude"`
	Province          sql.NullString `json:"province"`
	Municipality      sql.NullString `json:"municipality"`
	Neighborhood      sql.NullString `json:"neighborhood"`
	Address           sql.NullString `json:"address"`
	ImageUrl          sql.NullString `json:"image_url"`
	Status            interface{}    `json:"status"`
	ReviewedBy        uuid.NullUUID  `json:"reviewed_by"`
	ResolvedAt        sql.NullTime   `json:"resolved_at"`
	VerificationCount sql.NullInt32  `json:"verification_count"`
	RejectionCount    sql.NullInt32  `json:"rejection_count"`
	ExpiresAt         sql.NullTime   `json:"expires_at"`
	IsPrivate         bool           `json:"is_private"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	RiskTypeName      sql.NullString `json:"risk_type_name"`
	RiskTypeIconPath  sql.NullString `json:"risk_type_icon_path"`
	RiskTopicName     sql.NullString `json:"risk_topic_name"`
	RiskTopicIconPath sql.NullString `json:"risk_topic_icon_path"`
}

func (q *Queries) ListReportsByUser(ctx context.Context, userID uuid.UUID) ([]ListReportsByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listReportsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReportsByUserRow{}
	for rows.Next() {
		var i ListReportsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RiskTypeID,
			&i.RiskTopicID,
			&i.Description,
			&i.Latitude,
			&i.Longitude,
			&i.Province,
			&i.Municipality,
			&i.Neighborhood,
			&i.Address,
			&i.ImageUrl,
			&i.Status,
			&i.ReviewedBy,
			&i.ResolvedAt,
			&i.VerificationCount,
			&i.RejectionCount,
			&i.ExpiresAt,
			&i.IsPrivate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RiskTypeName,
			&i.RiskTypeIconPath,
			&i.RiskTopicName,
			&i.RiskTopicIconPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReportsWithPagination = `-- name: ListReportsWithPagination :many
SELECT
    r.id, r.user_id, r.risk_type_id, r.risk_topic_id, r.description,
    r.latitude, r.longitude, r.province, r.municipality, r.neighborhood,
    r.address, r.image_url, r.status, r.reviewed_by, r.resolved_at,
    r.verification_count, r.rejection_count, r.expires_at, r.is_private,
    r.created_at, r.updated_at,
    rt.name as risk_type_name,
    rt.icon_path as risk_type_icon_path,
    rtopic.name as risk_topic_name,
    rtopic.icon_path as risk_topic_icon_path
FROM reports r
LEFT JOIN risk_types rt ON r.risk_type_id = rt.id
LEFT JOIN risk_topics rtopic ON r.risk_topic_id = rtopic.id
WHERE ($4::text IS NULL OR r.status = $4::report_status) AND r.is_private = FALSE AND rt.is_enabled = TRUE
ORDER BY
    CASE WHEN $1 = 'desc' THEN r.created_at END DESC,
    CASE WHEN $1 = 'asc' THEN r.created_at END ASC
LIMIT $2 OFFSET $3
`

type ListReportsWithPaginationParams struct {
	Column1 interface{}    `json:"column_1"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
	Status  sql.NullString `json:"status"`
}

type ListReportsWithPaginationRow struct {
	ID                uuid.UUID      `json:"id"`
	UserID            uuid.UUID      `json:"user_id"`
	RiskTypeID        uuid.UUID      `json:"risk_type_id"`
	RiskTopicID       uuid.NullUUID  `json:"risk_topic_id"`
	Description       sql.NullString `json:"description"`
	Latitude          float64        `json:"latitude"`
	Longitude         float64        `json:"longitude"`
	Province          sql.NullString `json:"province"`
	Municipality      sql.NullString `json:"municipality"`
	Neighborhood      sql.NullString `json:"neighborhood"`
	Address           sql.NullString `json:"address"`
	ImageUrl          sql.NullString `json:"image_url"`
	Status            interface{}    `json:"status"`
	ReviewedBy        uuid.NullUUID  `json:"reviewed_by"`
	ResolvedAt        sql.NullTime   `json:"resolved_at"`
	VerificationCount sql.NullInt32  `json:"verification_count"`
	RejectionCount    sql.NullInt32  `json:"rejection_count"`
	ExpiresAt         sql.NullTime   `json:"expires_at"`
	IsPrivate         bool           `json:"is_private"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	RiskTypeName      sql.NullString `json:"risk_type_name"`
	RiskTypeIconPath  sql.NullString `json:"risk_type_icon_path"`
	RiskTopicName     sql.NullString `json:"risk_topic_name"`
	RiskTopicIconPath sql.NullString `json:"risk_topic_icon_path"`
}

func (q *Queries) ListReportsWithPagination(ctx context.Context, arg ListReportsWithPaginationParams) ([]ListReportsWithPaginationRow, error) {
	rows, err := q.db.QueryContext(ctx, listReportsWithPagination,
		arg.Column1,
		arg.Limit,
		arg.Offset,
		arg.Status,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReportsWithPaginationRow{}
	for rows.Next() {
		var i ListReportsWithPaginationRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RiskTypeID,
			&i.RiskTopicID,
			&i.Description,
			&i.Latitude,
			&i.Longitude,
			&i.Province,
			&i.Municipality,
			&i.Neighborhood,
			&i.Address,
			&i.ImageUrl,
			&i.Status,
			&i.ReviewedBy,
			&i.ResolvedAt,
			&i.VerificationCount,
			&i.RejectionCount,
			&i.ExpiresAt,
			&i.IsPrivate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.RiskTypeName,
			&i.RiskTypeIconPath,
			&i.RiskTopicName,
			&i.RiskTopicIconPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectReport = `-- name: RejectReport :exec
UPDATE reports
SET status = 'rejected',
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) RejectReport(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, rejectReport, id)
	return err
}

const removeAnonymousVote = `-- name: RemoveAnonymousVote :exec
DELETE FROM report_votes WHERE report_id = $1 AND anonymous_session_id = $2
`

type RemoveAnonymousVoteParams struct {
	ReportID           uuid.UUID     `json:"report_id"`
	AnonymousSessionID uuid.NullUUID `json:"anonymous_session_id"`
}

func (q *Queries) RemoveAnonymousVote(ctx context.Context, arg RemoveAnonymousVoteParams) error {
	_, err := q.db.ExecContext(ctx, removeAnonymousVote, arg.ReportID, arg.AnonymousSessionID)
	return err
}

const removeUserVote = `-- name: RemoveUserVote :exec
DELETE FROM report_votes WHERE report_id = $1 AND user_id = $2
`

type RemoveUserVoteParams struct {
	ReportID uuid.UUID     `json:"report_id"`
	UserID   uuid.NullUUID `json:"user_id"`
}

func (q *Queries) RemoveUserVote(ctx context.Context, arg RemoveUserVoteParams) error {
	_, err := q.db.ExecContext(ctx, removeUserVote, arg.ReportID, arg.UserID)
	return err
}

const resolveReport = `-- name: ResolveReport :exec
UPDATE reports
SET status = 'resolved',
    resolved_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) ResolveReport(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, resolveReport, id)
	return err
}

const updateReport = `-- name: UpdateReport :exec
UPDATE reports
SET description = $2,
    status = $3,
    updated_at = NOW()
WHERE id = $1
`

type UpdateReportParams struct {
	ID          uuid.UUID      `json:"id"`
	Description sql.NullString `json:"description"`
	Status      interface{}    `json:"status"`
}

func (q *Queries) UpdateReport(ctx context.Context, arg UpdateReportParams) error {
	_, err := q.db.ExecContext(ctx, updateReport, arg.ID, arg.Description, arg.Status)
	return err
}

const updateReportLocation = `-- name: UpdateReportLocation :one
UPDATE reports
SET latitude = $2,
    longitude = $3,
    address = COALESCE(NULLIF($4, ''), address),
    neighborhood = COALESCE(NULLIF($5, ''), neighborhood),
    municipality = COALESCE(NULLIF($6, ''), municipality),
    province = COALESCE(NULLIF($7, ''), province),
    updated_at = NOW()
WHERE id = $1
RETURNING id, updated_at
`

type UpdateReportLocationParams struct {
	ID        uuid.UUID   `json:"id"`
	Latitude  float64     `json:"latitude"`
	Longitude float64     `json:"longitude"`
	Column4   interface{} `json:"column_4"`
	Column5   interface{} `json:"column_5"`
	Column6   interface{} `json:"column_6"`
	Column7   interface{} `json:"column_7"`
}

type UpdateReportLocationRow struct {
	ID        uuid.UUID    `json:"id"`
	UpdatedAt sql.NullTime `json:"updated_at"`
}

func (q *Queries) UpdateReportLocation(ctx context.Context, arg UpdateReportLocationParams) (UpdateReportLocationRow, error) {
	row := q.db.QueryRowContext(ctx, updateReportLocation,
		arg.ID,
		arg.Latitude,
		arg.Longitude,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
	)
	var i UpdateReportLocationRow
	err := row.Scan(&i.ID, &i.UpdatedAt)
	return i, err
}

const updateUserTrustScore = `-- name: UpdateUserTrustScore :exec
UPDATE users SET trust_score = $2, updated_at = NOW() WHERE id = $1
`

type UpdateUserTrustScoreParams struct {
	ID         uuid.UUID     `json:"id"`
	TrustScore sql.NullInt32 `json:"trust_score"`
}

func (q *Queries) UpdateUserTrustScore(ctx context.Context, arg UpdateUserTrustScoreParams) error {
	_, err := q.db.ExecContext(ctx, updateUserTrustScore, arg.ID, arg.TrustScore)
	return err
}

const updateVerificationCounts = `-- name: UpdateVerificationCounts :exec
UPDATE reports 
SET verification_count = $2, rejection_count = $3, updated_at = NOW()
WHERE id = $1
`

type UpdateVerificationCountsParams struct {
	ID                uuid.UUID     `json:"id"`
	VerificationCount sql.NullInt32 `json:"verification_count"`
	RejectionCount    sql.NullInt32 `json:"rejection_count"`
}

func (q *Queries) UpdateVerificationCounts(ctx context.Context, arg UpdateVerificationCountsParams) error {
	_, err := q.db.ExecContext(ctx, updateVerificationCounts, arg.ID, arg.VerificationCount, arg.RejectionCount)
	return err
}

const verifyReport = `-- name: VerifyReport :exec
UPDATE reports
SET status = 'verified', reviewed_by = $2, updated_at = NOW()
WHERE id = $1
`

type VerifyReportParams struct {
	ID         uuid.UUID     `json:"id"`
	ReviewedBy uuid.NullUUID `json:"reviewed_by"`
}

func (q *Queries) VerifyReport(ctx context.Context, arg VerifyReportParams) error {
	_, err := q.db.ExecContext(ctx, verifyReport, arg.ID, arg.ReviewedBy)
	return err
}
