// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: reports.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createReport = `-- name: CreateReport :exec
INSERT INTO reports (
    user_id, risk_type_id, risk_topic_id, description,
    latitude, longitude, province, municipality,
    neighborhood, address, image_url
) VALUES (
             $1, $2, $3, $4, $5,
             $6, $7, $8, $9, $10, $11
         )
`

type CreateReportParams struct {
	UserID       uuid.UUID      `json:"user_id"`
	RiskTypeID   uuid.UUID      `json:"risk_type_id"`
	RiskTopicID  uuid.NullUUID  `json:"risk_topic_id"`
	Description  sql.NullString `json:"description"`
	Latitude     float64        `json:"latitude"`
	Longitude    float64        `json:"longitude"`
	Province     sql.NullString `json:"province"`
	Municipality sql.NullString `json:"municipality"`
	Neighborhood sql.NullString `json:"neighborhood"`
	Address      sql.NullString `json:"address"`
	ImageUrl     sql.NullString `json:"image_url"`
}

func (q *Queries) CreateReport(ctx context.Context, arg CreateReportParams) error {
	_, err := q.db.ExecContext(ctx, createReport,
		arg.UserID,
		arg.RiskTypeID,
		arg.RiskTopicID,
		arg.Description,
		arg.Latitude,
		arg.Longitude,
		arg.Province,
		arg.Municipality,
		arg.Neighborhood,
		arg.Address,
		arg.ImageUrl,
	)
	return err
}

const createReportNotification = `-- name: CreateReportNotification :exec
INSERT INTO notifications (type, reference_id, user_id) VALUES ($1, $2, $3)
ON CONFLICT (type, reference_id, user_id) DO NOTHING
`

type CreateReportNotificationParams struct {
	Type        NotificationType `json:"type"`
	ReferenceID uuid.UUID        `json:"reference_id"`
	UserID      uuid.UUID        `json:"user_id"`
}

func (q *Queries) CreateReportNotification(ctx context.Context, arg CreateReportNotificationParams) error {
	_, err := q.db.ExecContext(ctx, createReportNotification, arg.Type, arg.ReferenceID, arg.UserID)
	return err
}

const deleteReport = `-- name: DeleteReport :exec
DELETE FROM reports WHERE id = $1
`

func (q *Queries) DeleteReport(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteReport, id)
	return err
}

const getReportByID = `-- name: GetReportByID :one
SELECT id, user_id, risk_type_id, risk_topic_id, description, latitude, longitude, province, municipality, neighborhood, address, image_url, status, reviewed_by, resolved_at, created_at, updated_at FROM reports WHERE id = $1
`

func (q *Queries) GetReportByID(ctx context.Context, id uuid.UUID) (Report, error) {
	row := q.db.QueryRowContext(ctx, getReportByID, id)
	var i Report
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RiskTypeID,
		&i.RiskTopicID,
		&i.Description,
		&i.Latitude,
		&i.Longitude,
		&i.Province,
		&i.Municipality,
		&i.Neighborhood,
		&i.Address,
		&i.ImageUrl,
		&i.Status,
		&i.ReviewedBy,
		&i.ResolvedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listReportsByStatus = `-- name: ListReportsByStatus :many
SELECT id, user_id, risk_type_id, risk_topic_id, description, latitude, longitude, province, municipality, neighborhood, address, image_url, status, reviewed_by, resolved_at, created_at, updated_at FROM reports WHERE status = $1 ORDER BY created_at DESC
`

func (q *Queries) ListReportsByStatus(ctx context.Context, status interface{}) ([]Report, error) {
	rows, err := q.db.QueryContext(ctx, listReportsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Report{}
	for rows.Next() {
		var i Report
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RiskTypeID,
			&i.RiskTopicID,
			&i.Description,
			&i.Latitude,
			&i.Longitude,
			&i.Province,
			&i.Municipality,
			&i.Neighborhood,
			&i.Address,
			&i.ImageUrl,
			&i.Status,
			&i.ReviewedBy,
			&i.ResolvedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReportsByUser = `-- name: ListReportsByUser :many
SELECT id, user_id, risk_type_id, risk_topic_id, description, latitude, longitude, province, municipality, neighborhood, address, image_url, status, reviewed_by, resolved_at, created_at, updated_at FROM reports WHERE user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListReportsByUser(ctx context.Context, userID uuid.UUID) ([]Report, error) {
	rows, err := q.db.QueryContext(ctx, listReportsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Report{}
	for rows.Next() {
		var i Report
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RiskTypeID,
			&i.RiskTopicID,
			&i.Description,
			&i.Latitude,
			&i.Longitude,
			&i.Province,
			&i.Municipality,
			&i.Neighborhood,
			&i.Address,
			&i.ImageUrl,
			&i.Status,
			&i.ReviewedBy,
			&i.ResolvedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReportsNearby = `-- name: ListReportsNearby :many
SELECT
    id, user_id, risk_type_id, risk_topic_id, description,
    latitude, longitude, province, municipality, neighborhood,
    address, image_url, status, reviewed_by, resolved_at,
    created_at, updated_at
FROM reports
WHERE ST_DWithin(
              geography(ST_MakePoint(longitude, latitude)),
              geography(ST_MakePoint($1::float8, $2::float8)),
              $3::float8
      )
ORDER BY created_at DESC
`

type ListReportsNearbyParams struct {
	Column1 float64 `json:"column_1"`
	Column2 float64 `json:"column_2"`
	Column3 float64 `json:"column_3"`
}

func (q *Queries) ListReportsNearby(ctx context.Context, arg ListReportsNearbyParams) ([]Report, error) {
	rows, err := q.db.QueryContext(ctx, listReportsNearby, arg.Column1, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Report{}
	for rows.Next() {
		var i Report
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RiskTypeID,
			&i.RiskTopicID,
			&i.Description,
			&i.Latitude,
			&i.Longitude,
			&i.Province,
			&i.Municipality,
			&i.Neighborhood,
			&i.Address,
			&i.ImageUrl,
			&i.Status,
			&i.ReviewedBy,
			&i.ResolvedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectReport = `-- name: RejectReport :exec
UPDATE reports
SET status = 'rejected',
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) RejectReport(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, rejectReport, id)
	return err
}

const resolveReport = `-- name: ResolveReport :exec
UPDATE reports
SET status = 'resolved',
    resolved_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) ResolveReport(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, resolveReport, id)
	return err
}

const updateReport = `-- name: UpdateReport :exec
UPDATE reports
SET description = $2,
    status = $3,
    updated_at = NOW()
WHERE id = $1
`

type UpdateReportParams struct {
	ID          uuid.UUID      `json:"id"`
	Description sql.NullString `json:"description"`
	Status      interface{}    `json:"status"`
}

func (q *Queries) UpdateReport(ctx context.Context, arg UpdateReportParams) error {
	_, err := q.db.ExecContext(ctx, updateReport, arg.ID, arg.Description, arg.Status)
	return err
}

const verifyReport = `-- name: VerifyReport :exec
UPDATE reports
SET status = 'verified', reviewed_by = $2, updated_at = NOW()
WHERE id = $1
`

type VerifyReportParams struct {
	ID         uuid.UUID     `json:"id"`
	ReviewedBy uuid.NullUUID `json:"reviewed_by"`
}

func (q *Queries) VerifyReport(ctx context.Context, arg VerifyReportParams) error {
	_, err := q.db.ExecContext(ctx, verifyReport, arg.ID, arg.ReviewedBy)
	return err
}
