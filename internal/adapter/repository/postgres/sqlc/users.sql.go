// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: users.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const addCodeToUser = `-- name: AddCodeToUser :exec
UPDATE users
SET email_verification_code = $2, email_verification_expires_at = $3, updated_at = $4, email_verified = false
WHERE id = $1
`

type AddCodeToUserParams struct {
	ID                         uuid.UUID      `json:"id"`
	EmailVerificationCode      sql.NullString `json:"email_verification_code"`
	EmailVerificationExpiresAt sql.NullTime   `json:"email_verification_expires_at"`
	UpdatedAt                  sql.NullTime   `json:"updated_at"`
}

func (q *Queries) AddCodeToUser(ctx context.Context, arg AddCodeToUserParams) error {
	_, err := q.db.ExecContext(ctx, addCodeToUser,
		arg.ID,
		arg.EmailVerificationCode,
		arg.EmailVerificationExpiresAt,
		arg.UpdatedAt,
	)
	return err
}

const createUser = `-- name: CreateUser :exec
INSERT INTO users (id, name, email, password, phone)
VALUES ($1, $2, $3, $4, $5)
`

type CreateUserParams struct {
	ID       uuid.UUID      `json:"id"`
	Name     string         `json:"name"`
	Email    string         `json:"email"`
	Password string         `json:"password"`
	Phone    sql.NullString `json:"phone"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, createUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Password,
		arg.Phone,
	)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, password, phone, latitude, longitude, alert_radius_meters, email_verified, email_verification_code, email_verification_expires_at, nif, province, municipality, neighborhood, address, zip_code, country, last_login, home_address_name, home_address_address, home_address_lat, home_address_lon, work_address_name, work_address_address, work_address_lat, work_address_lon, failed_attempts, locked_until, device_fcm_token, device_language, created_at, updated_at, deleted_at, linked_device_id FROM users WHERE email = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.Phone,
		&i.Latitude,
		&i.Longitude,
		&i.AlertRadiusMeters,
		&i.EmailVerified,
		&i.EmailVerificationCode,
		&i.EmailVerificationExpiresAt,
		&i.Nif,
		&i.Province,
		&i.Municipality,
		&i.Neighborhood,
		&i.Address,
		&i.ZipCode,
		&i.Country,
		&i.LastLogin,
		&i.HomeAddressName,
		&i.HomeAddressAddress,
		&i.HomeAddressLat,
		&i.HomeAddressLon,
		&i.WorkAddressName,
		&i.WorkAddressAddress,
		&i.WorkAddressLat,
		&i.WorkAddressLon,
		&i.FailedAttempts,
		&i.LockedUntil,
		&i.DeviceFcmToken,
		&i.DeviceLanguage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.LinkedDeviceID,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, name, email, password, phone, latitude, longitude, alert_radius_meters, email_verified, email_verification_code, email_verification_expires_at, nif, province, municipality, neighborhood, address, zip_code, country, last_login, home_address_name, home_address_address, home_address_lat, home_address_lon, work_address_name, work_address_address, work_address_lat, work_address_lon, failed_attempts, locked_until, device_fcm_token, device_language, created_at, updated_at, deleted_at, linked_device_id FROM users WHERE id = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
		&i.Phone,
		&i.Latitude,
		&i.Longitude,
		&i.AlertRadiusMeters,
		&i.EmailVerified,
		&i.EmailVerificationCode,
		&i.EmailVerificationExpiresAt,
		&i.Nif,
		&i.Province,
		&i.Municipality,
		&i.Neighborhood,
		&i.Address,
		&i.ZipCode,
		&i.Country,
		&i.LastLogin,
		&i.HomeAddressName,
		&i.HomeAddressAddress,
		&i.HomeAddressLat,
		&i.HomeAddressLon,
		&i.WorkAddressName,
		&i.WorkAddressAddress,
		&i.WorkAddressLat,
		&i.WorkAddressLon,
		&i.FailedAttempts,
		&i.LockedUntil,
		&i.DeviceFcmToken,
		&i.DeviceLanguage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.LinkedDeviceID,
	)
	return i, err
}

const listAllDeviceTokensExceptUser = `-- name: ListAllDeviceTokensExceptUser :many
SELECT device_fcm_token, device_language
FROM users
WHERE deleted_at IS NULL
  AND device_fcm_token IS NOT NULL
  AND id <> $1
`

type ListAllDeviceTokensExceptUserRow struct {
	DeviceFcmToken sql.NullString `json:"device_fcm_token"`
	DeviceLanguage sql.NullString `json:"device_language"`
}

func (q *Queries) ListAllDeviceTokensExceptUser(ctx context.Context, id uuid.UUID) ([]ListAllDeviceTokensExceptUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllDeviceTokensExceptUser, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllDeviceTokensExceptUserRow{}
	for rows.Next() {
		var i ListAllDeviceTokensExceptUserRow
		if err := rows.Scan(&i.DeviceFcmToken, &i.DeviceLanguage); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDeviceTokensByUserIDs = `-- name: ListDeviceTokensByUserIDs :many
SELECT device_fcm_token, device_language
FROM users
WHERE deleted_at IS NULL
  AND device_fcm_token IS NOT NULL
  AND id IN (SELECT UNNEST($1::uuid[]))
`

type ListDeviceTokensByUserIDsRow struct {
	DeviceFcmToken sql.NullString `json:"device_fcm_token"`
	DeviceLanguage sql.NullString `json:"device_language"`
}

func (q *Queries) ListDeviceTokensByUserIDs(ctx context.Context, dollar_1 []uuid.UUID) ([]ListDeviceTokensByUserIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, listDeviceTokensByUserIDs, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDeviceTokensByUserIDsRow{}
	for rows.Next() {
		var i ListDeviceTokensByUserIDsRow
		if err := rows.Scan(&i.DeviceFcmToken, &i.DeviceLanguage); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNearbyUsers = `-- name: ListNearbyUsers :many
SELECT id, name, email, password, phone, latitude, longitude, alert_radius_meters, email_verified, email_verification_code, email_verification_expires_at, nif, province, municipality, neighborhood, address, zip_code, country, last_login, home_address_name, home_address_address, home_address_lat, home_address_lon, work_address_name, work_address_address, work_address_lat, work_address_lon, failed_attempts, locked_until, device_fcm_token, device_language, created_at, updated_at, deleted_at, linked_device_id
FROM users
WHERE deleted_at IS NULL
  AND (latitude IS NOT NULL AND longitude IS NOT NULL)
`

func (q *Queries) ListNearbyUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listNearbyUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
			&i.Phone,
			&i.Latitude,
			&i.Longitude,
			&i.AlertRadiusMeters,
			&i.EmailVerified,
			&i.EmailVerificationCode,
			&i.EmailVerificationExpiresAt,
			&i.Nif,
			&i.Province,
			&i.Municipality,
			&i.Neighborhood,
			&i.Address,
			&i.ZipCode,
			&i.Country,
			&i.LastLogin,
			&i.HomeAddressName,
			&i.HomeAddressAddress,
			&i.HomeAddressLat,
			&i.HomeAddressLon,
			&i.WorkAddressName,
			&i.WorkAddressAddress,
			&i.WorkAddressLat,
			&i.WorkAddressLon,
			&i.FailedAttempts,
			&i.LockedUntil,
			&i.DeviceFcmToken,
			&i.DeviceLanguage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.LinkedDeviceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markEmailVerified = `-- name: MarkEmailVerified :exec
UPDATE users SET email_verified = TRUE, email_verification_code = NULL WHERE id = $1
`

func (q *Queries) MarkEmailVerified(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, markEmailVerified, id)
	return err
}

const updateAlertRadius = `-- name: UpdateAlertRadius :exec
UPDATE users SET alert_radius_meters = $2 WHERE id = $1
`

type UpdateAlertRadiusParams struct {
	ID                uuid.UUID     `json:"id"`
	AlertRadiusMeters sql.NullInt32 `json:"alert_radius_meters"`
}

func (q *Queries) UpdateAlertRadius(ctx context.Context, arg UpdateAlertRadiusParams) error {
	_, err := q.db.ExecContext(ctx, updateAlertRadius, arg.ID, arg.AlertRadiusMeters)
	return err
}

const updateEmailVerificationCode = `-- name: UpdateEmailVerificationCode :exec
UPDATE users
SET email_verification_code = $2,
    email_verification_expires_at = $3
WHERE id = $1
`

type UpdateEmailVerificationCodeParams struct {
	ID                         uuid.UUID      `json:"id"`
	EmailVerificationCode      sql.NullString `json:"email_verification_code"`
	EmailVerificationExpiresAt sql.NullTime   `json:"email_verification_expires_at"`
}

func (q *Queries) UpdateEmailVerificationCode(ctx context.Context, arg UpdateEmailVerificationCodeParams) error {
	_, err := q.db.ExecContext(ctx, updateEmailVerificationCode, arg.ID, arg.EmailVerificationCode, arg.EmailVerificationExpiresAt)
	return err
}

const updateUserDeviceInfo = `-- name: UpdateUserDeviceInfo :exec
UPDATE users
SET device_fcm_token = $2,
    device_language = $3,
    updated_at = NOW()
WHERE id = $1
`

type UpdateUserDeviceInfoParams struct {
	ID             uuid.UUID      `json:"id"`
	DeviceFcmToken sql.NullString `json:"device_fcm_token"`
	DeviceLanguage sql.NullString `json:"device_language"`
}

func (q *Queries) UpdateUserDeviceInfo(ctx context.Context, arg UpdateUserDeviceInfoParams) error {
	_, err := q.db.ExecContext(ctx, updateUserDeviceInfo, arg.ID, arg.DeviceFcmToken, arg.DeviceLanguage)
	return err
}

const updateUserLocation = `-- name: UpdateUserLocation :exec
UPDATE users
SET latitude = $2,
    longitude = $3,
    province = $4,
    municipality = $5,
    neighborhood = $6,
    address = $7,
    updated_at = NOW()
WHERE id = $1
`

type UpdateUserLocationParams struct {
	ID           uuid.UUID       `json:"id"`
	Latitude     sql.NullFloat64 `json:"latitude"`
	Longitude    sql.NullFloat64 `json:"longitude"`
	Province     sql.NullString  `json:"province"`
	Municipality sql.NullString  `json:"municipality"`
	Neighborhood sql.NullString  `json:"neighborhood"`
	Address      sql.NullString  `json:"address"`
}

func (q *Queries) UpdateUserLocation(ctx context.Context, arg UpdateUserLocationParams) error {
	_, err := q.db.ExecContext(ctx, updateUserLocation,
		arg.ID,
		arg.Latitude,
		arg.Longitude,
		arg.Province,
		arg.Municipality,
		arg.Neighborhood,
		arg.Address,
	)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users
SET password = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateUserPasswordParams struct {
	ID       uuid.UUID `json:"id"`
	Password string    `json:"password"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, arg.ID, arg.Password)
	return err
}

const updateUserSavedLocations = `-- name: UpdateUserSavedLocations :exec
UPDATE users
SET home_address_name = $2,
    home_address_address = $3,
    home_address_lat = $4,
    home_address_lon = $5,
    work_address_name = $6,
    work_address_address = $7,
    work_address_lat = $8,
    work_address_lon = $9,
    updated_at = NOW()
WHERE id = $1
`

type UpdateUserSavedLocationsParams struct {
	ID                 uuid.UUID       `json:"id"`
	HomeAddressName    sql.NullString  `json:"home_address_name"`
	HomeAddressAddress sql.NullString  `json:"home_address_address"`
	HomeAddressLat     sql.NullFloat64 `json:"home_address_lat"`
	HomeAddressLon     sql.NullFloat64 `json:"home_address_lon"`
	WorkAddressName    sql.NullString  `json:"work_address_name"`
	WorkAddressAddress sql.NullString  `json:"work_address_address"`
	WorkAddressLat     sql.NullFloat64 `json:"work_address_lat"`
	WorkAddressLon     sql.NullFloat64 `json:"work_address_lon"`
}

func (q *Queries) UpdateUserSavedLocations(ctx context.Context, arg UpdateUserSavedLocationsParams) error {
	_, err := q.db.ExecContext(ctx, updateUserSavedLocations,
		arg.ID,
		arg.HomeAddressName,
		arg.HomeAddressAddress,
		arg.HomeAddressLat,
		arg.HomeAddressLon,
		arg.WorkAddressName,
		arg.WorkAddressAddress,
		arg.WorkAddressLat,
		arg.WorkAddressLon,
	)
	return err
}
