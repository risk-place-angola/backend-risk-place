// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: anonymous_migration.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createAnonymousMigration = `-- name: CreateAnonymousMigration :exec
INSERT INTO anonymous_user_migrations (
    id,
    anonymous_session_id,
    device_id,
    user_id,
    migration_type,
    started_at
) VALUES (
    $1::UUID,
    $2::UUID,
    $3,
    $4::UUID,
    $5,
    NOW()
)
`

type CreateAnonymousMigrationParams struct {
	ID                 uuid.UUID `json:"id"`
	AnonymousSessionID uuid.UUID `json:"anonymous_session_id"`
	DeviceID           string    `json:"device_id"`
	UserID             uuid.UUID `json:"user_id"`
	MigrationType      string    `json:"migration_type"`
}

// Cria um novo log de migração
func (q *Queries) CreateAnonymousMigration(ctx context.Context, arg CreateAnonymousMigrationParams) error {
	_, err := q.db.ExecContext(ctx, createAnonymousMigration,
		arg.ID,
		arg.AnonymousSessionID,
		arg.DeviceID,
		arg.UserID,
		arg.MigrationType,
	)
	return err
}

const createDeviceUserMapping = `-- name: CreateDeviceUserMapping :exec
INSERT INTO device_user_mappings (
    id,
    device_id,
    anonymous_session_id,
    user_id,
    mapped_at,
    is_active
) VALUES (
    $1::UUID,
    $2,
    $3::UUID,
    $4::UUID,
    NOW(),
    true
)
`

type CreateDeviceUserMappingParams struct {
	ID                 uuid.UUID `json:"id"`
	DeviceID           string    `json:"device_id"`
	AnonymousSessionID uuid.UUID `json:"anonymous_session_id"`
	UserID             uuid.UUID `json:"user_id"`
}

// Cria um novo mapeamento device ↔ user
func (q *Queries) CreateDeviceUserMapping(ctx context.Context, arg CreateDeviceUserMappingParams) error {
	_, err := q.db.ExecContext(ctx, createDeviceUserMapping,
		arg.ID,
		arg.DeviceID,
		arg.AnonymousSessionID,
		arg.UserID,
	)
	return err
}

const deactivateDeviceUserMapping = `-- name: DeactivateDeviceUserMapping :exec
UPDATE device_user_mappings
SET is_active = false,
    unmapped_at = NOW()
WHERE id = $1::UUID
`

// Marca um mapeamento como inativo
func (q *Queries) DeactivateDeviceUserMapping(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deactivateDeviceUserMapping, id)
	return err
}

const deleteAnonymousSafetySettings = `-- name: DeleteAnonymousSafetySettings :exec

DELETE FROM user_safety_settings
WHERE anonymous_session_id = $1::UUID
`

// Apenas se anon mais recente
// Remove configurações anônimas após merge
func (q *Queries) DeleteAnonymousSafetySettings(ctx context.Context, anonymousSessionID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteAnonymousSafetySettings, anonymousSessionID)
	return err
}

const getActiveDeviceUserMapping = `-- name: GetActiveDeviceUserMapping :one
SELECT id, device_id, anonymous_session_id, user_id, mapped_at, unmapped_at, is_active FROM device_user_mappings
WHERE device_id = $1
  AND is_active = true
LIMIT 1
`

// Retorna o mapeamento ativo de um device
func (q *Queries) GetActiveDeviceUserMapping(ctx context.Context, deviceID string) (DeviceUserMapping, error) {
	row := q.db.QueryRowContext(ctx, getActiveDeviceUserMapping, deviceID)
	var i DeviceUserMapping
	err := row.Scan(
		&i.ID,
		&i.DeviceID,
		&i.AnonymousSessionID,
		&i.UserID,
		&i.MappedAt,
		&i.UnmappedAt,
		&i.IsActive,
	)
	return i, err
}

const getAnonymousDataCounts = `-- name: GetAnonymousDataCounts :one
SELECT
    COALESCE((SELECT COUNT(*) FROM alerts WHERE anonymous_session_id = $1::UUID), 0) AS alerts_count,
    COALESCE((SELECT COUNT(*) FROM alert_subscriptions WHERE anonymous_session_id = $1::UUID), 0) AS subscriptions_count,
    COALESCE((SELECT COUNT(*) FROM user_safety_settings WHERE anonymous_session_id = $1::UUID), 0) AS settings_count,
    COALESCE((SELECT COUNT(*) FROM location_sharings WHERE anonymous_session_id = $1::UUID), 0) AS location_sharings_count
`

type GetAnonymousDataCountsRow struct {
	AlertsCount           interface{} `json:"alerts_count"`
	SubscriptionsCount    interface{} `json:"subscriptions_count"`
	SettingsCount         interface{} `json:"settings_count"`
	LocationSharingsCount interface{} `json:"location_sharings_count"`
}

// Retorna contadores de dados anônimos antes da migração
func (q *Queries) GetAnonymousDataCounts(ctx context.Context, anonymousSessionID uuid.UUID) (GetAnonymousDataCountsRow, error) {
	row := q.db.QueryRowContext(ctx, getAnonymousDataCounts, anonymousSessionID)
	var i GetAnonymousDataCountsRow
	err := row.Scan(
		&i.AlertsCount,
		&i.SubscriptionsCount,
		&i.SettingsCount,
		&i.LocationSharingsCount,
	)
	return i, err
}

const getDeviceUserMappingsByUserID = `-- name: GetDeviceUserMappingsByUserID :many
SELECT id, device_id, anonymous_session_id, user_id, mapped_at, unmapped_at, is_active FROM device_user_mappings
WHERE user_id = $1::UUID
ORDER BY mapped_at DESC
`

// Retorna todos os devices vinculados a um usuário
func (q *Queries) GetDeviceUserMappingsByUserID(ctx context.Context, userID uuid.UUID) ([]DeviceUserMapping, error) {
	rows, err := q.db.QueryContext(ctx, getDeviceUserMappingsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DeviceUserMapping{}
	for rows.Next() {
		var i DeviceUserMapping
		if err := rows.Scan(
			&i.ID,
			&i.DeviceID,
			&i.AnonymousSessionID,
			&i.UserID,
			&i.MappedAt,
			&i.UnmappedAt,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMigrationByID = `-- name: GetMigrationByID :one
SELECT id, anonymous_session_id, device_id, user_id, alerts_migrated, subscriptions_migrated, settings_migrated, location_sharings_migrated, migration_type, started_at, completed_at, failed_at, error_message FROM anonymous_user_migrations
WHERE id = $1::UUID
`

// Retorna uma migração específica
func (q *Queries) GetMigrationByID(ctx context.Context, id uuid.UUID) (AnonymousUserMigration, error) {
	row := q.db.QueryRowContext(ctx, getMigrationByID, id)
	var i AnonymousUserMigration
	err := row.Scan(
		&i.ID,
		&i.AnonymousSessionID,
		&i.DeviceID,
		&i.UserID,
		&i.AlertsMigrated,
		&i.SubscriptionsMigrated,
		&i.SettingsMigrated,
		&i.LocationSharingsMigrated,
		&i.MigrationType,
		&i.StartedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
	)
	return i, err
}

const getMigrationStats = `-- name: GetMigrationStats :one

SELECT
    COUNT(*) AS total_migrations,
    COUNT(*) FILTER (WHERE completed_at IS NOT NULL) AS completed_count,
    COUNT(*) FILTER (WHERE failed_at IS NOT NULL) AS failed_count,
    COUNT(*) FILTER (WHERE migration_type = 'signup') AS signup_count,
    COUNT(*) FILTER (WHERE migration_type = 'login') AS login_count,
    COALESCE(AVG(alerts_migrated), 0) AS avg_alerts_per_migration,
    COALESCE(AVG(subscriptions_migrated), 0) AS avg_subscriptions_per_migration
FROM anonymous_user_migrations
WHERE started_at >= $1::TIMESTAMP
`

type GetMigrationStatsRow struct {
	TotalMigrations              int64       `json:"total_migrations"`
	CompletedCount               int64       `json:"completed_count"`
	FailedCount                  int64       `json:"failed_count"`
	SignupCount                  int64       `json:"signup_count"`
	LoginCount                   int64       `json:"login_count"`
	AvgAlertsPerMigration        interface{} `json:"avg_alerts_per_migration"`
	AvgSubscriptionsPerMigration interface{} `json:"avg_subscriptions_per_migration"`
}

// ============================================================================
// ANALYTICS QUERIES
// ============================================================================
// Retorna estatísticas gerais de migrações
func (q *Queries) GetMigrationStats(ctx context.Context, since time.Time) (GetMigrationStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getMigrationStats, since)
	var i GetMigrationStatsRow
	err := row.Scan(
		&i.TotalMigrations,
		&i.CompletedCount,
		&i.FailedCount,
		&i.SignupCount,
		&i.LoginCount,
		&i.AvgAlertsPerMigration,
		&i.AvgSubscriptionsPerMigration,
	)
	return i, err
}

const getMigrationsByDeviceID = `-- name: GetMigrationsByDeviceID :many
SELECT id, anonymous_session_id, device_id, user_id, alerts_migrated, subscriptions_migrated, settings_migrated, location_sharings_migrated, migration_type, started_at, completed_at, failed_at, error_message FROM anonymous_user_migrations
WHERE device_id = $1
ORDER BY started_at DESC
`

// Retorna todas as migrações de um device
func (q *Queries) GetMigrationsByDeviceID(ctx context.Context, deviceID string) ([]AnonymousUserMigration, error) {
	rows, err := q.db.QueryContext(ctx, getMigrationsByDeviceID, deviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AnonymousUserMigration{}
	for rows.Next() {
		var i AnonymousUserMigration
		if err := rows.Scan(
			&i.ID,
			&i.AnonymousSessionID,
			&i.DeviceID,
			&i.UserID,
			&i.AlertsMigrated,
			&i.SubscriptionsMigrated,
			&i.SettingsMigrated,
			&i.LocationSharingsMigrated,
			&i.MigrationType,
			&i.StartedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMigrationsByUserID = `-- name: GetMigrationsByUserID :many
SELECT id, anonymous_session_id, device_id, user_id, alerts_migrated, subscriptions_migrated, settings_migrated, location_sharings_migrated, migration_type, started_at, completed_at, failed_at, error_message FROM anonymous_user_migrations
WHERE user_id = $1::UUID
ORDER BY started_at DESC
`

// Retorna todas as migrações de um usuário
func (q *Queries) GetMigrationsByUserID(ctx context.Context, userID uuid.UUID) ([]AnonymousUserMigration, error) {
	rows, err := q.db.QueryContext(ctx, getMigrationsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AnonymousUserMigration{}
	for rows.Next() {
		var i AnonymousUserMigration
		if err := rows.Scan(
			&i.ID,
			&i.AnonymousSessionID,
			&i.DeviceID,
			&i.UserID,
			&i.AlertsMigrated,
			&i.SubscriptionsMigrated,
			&i.SettingsMigrated,
			&i.LocationSharingsMigrated,
			&i.MigrationType,
			&i.StartedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentFailedMigrations = `-- name: GetRecentFailedMigrations :many
SELECT id, anonymous_session_id, device_id, user_id, alerts_migrated, subscriptions_migrated, settings_migrated, location_sharings_migrated, migration_type, started_at, completed_at, failed_at, error_message FROM anonymous_user_migrations
WHERE failed_at IS NOT NULL
ORDER BY failed_at DESC
LIMIT $1
`

// Retorna migrações falhadas recentes para debug
func (q *Queries) GetRecentFailedMigrations(ctx context.Context, limit int32) ([]AnonymousUserMigration, error) {
	rows, err := q.db.QueryContext(ctx, getRecentFailedMigrations, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AnonymousUserMigration{}
	for rows.Next() {
		var i AnonymousUserMigration
		if err := rows.Scan(
			&i.ID,
			&i.AnonymousSessionID,
			&i.DeviceID,
			&i.UserID,
			&i.AlertsMigrated,
			&i.SubscriptionsMigrated,
			&i.SettingsMigrated,
			&i.LocationSharingsMigrated,
			&i.MigrationType,
			&i.StartedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.ErrorMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSafetySettingsByAnonymousSession = `-- name: GetSafetySettingsByAnonymousSession :one

SELECT id, user_id, anonymous_session_id, device_id, notifications_enabled, notification_alert_types, notification_alert_radius_mins, notification_report_types, notification_report_radius_mins, location_sharing_enabled, location_history_enabled, profile_visibility, anonymous_reports, show_online_status, auto_alerts_enabled, danger_zones_enabled, time_based_alerts_enabled, high_risk_start_time, high_risk_end_time, night_mode_enabled, night_mode_start_time, night_mode_end_time, created_at, updated_at FROM user_safety_settings
WHERE anonymous_session_id = $1::UUID
LIMIT 1
`

// ============================================================================
// QUERIES FOR MERGE STRATEGY (Settings Conflict Resolution)
// ============================================================================
// Retorna configurações de uma sessão anônima
func (q *Queries) GetSafetySettingsByAnonymousSession(ctx context.Context, anonymousSessionID uuid.UUID) (UserSafetySetting, error) {
	row := q.db.QueryRowContext(ctx, getSafetySettingsByAnonymousSession, anonymousSessionID)
	var i UserSafetySetting
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AnonymousSessionID,
		&i.DeviceID,
		&i.NotificationsEnabled,
		pq.Array(&i.NotificationAlertTypes),
		&i.NotificationAlertRadiusMins,
		pq.Array(&i.NotificationReportTypes),
		&i.NotificationReportRadiusMins,
		&i.LocationSharingEnabled,
		&i.LocationHistoryEnabled,
		&i.ProfileVisibility,
		&i.AnonymousReports,
		&i.ShowOnlineStatus,
		&i.AutoAlertsEnabled,
		&i.DangerZonesEnabled,
		&i.TimeBasedAlertsEnabled,
		&i.HighRiskStartTime,
		&i.HighRiskEndTime,
		&i.NightModeEnabled,
		&i.NightModeStartTime,
		&i.NightModeEndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserMigrationHistory = `-- name: GetUserMigrationHistory :many
SELECT 
    m.id, m.anonymous_session_id, m.device_id, m.user_id, m.alerts_migrated, m.subscriptions_migrated, m.settings_migrated, m.location_sharings_migrated, m.migration_type, m.started_at, m.completed_at, m.failed_at, m.error_message,
    s.device_platform,
    s.device_model
FROM anonymous_user_migrations m
JOIN anonymous_sessions s ON m.anonymous_session_id = s.id
WHERE m.user_id = $1::UUID
ORDER BY m.started_at DESC
`

type GetUserMigrationHistoryRow struct {
	ID                       uuid.UUID      `json:"id"`
	AnonymousSessionID       uuid.UUID      `json:"anonymous_session_id"`
	DeviceID                 string         `json:"device_id"`
	UserID                   uuid.UUID      `json:"user_id"`
	AlertsMigrated           int32          `json:"alerts_migrated"`
	SubscriptionsMigrated    int32          `json:"subscriptions_migrated"`
	SettingsMigrated         bool           `json:"settings_migrated"`
	LocationSharingsMigrated int32          `json:"location_sharings_migrated"`
	MigrationType            string         `json:"migration_type"`
	StartedAt                time.Time      `json:"started_at"`
	CompletedAt              sql.NullTime   `json:"completed_at"`
	FailedAt                 sql.NullTime   `json:"failed_at"`
	ErrorMessage             sql.NullString `json:"error_message"`
	DevicePlatform           sql.NullString `json:"device_platform"`
	DeviceModel              sql.NullString `json:"device_model"`
}

// Retorna histórico completo de migrações de um usuário
func (q *Queries) GetUserMigrationHistory(ctx context.Context, userID uuid.UUID) ([]GetUserMigrationHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserMigrationHistory, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserMigrationHistoryRow{}
	for rows.Next() {
		var i GetUserMigrationHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.AnonymousSessionID,
			&i.DeviceID,
			&i.UserID,
			&i.AlertsMigrated,
			&i.SubscriptionsMigrated,
			&i.SettingsMigrated,
			&i.LocationSharingsMigrated,
			&i.MigrationType,
			&i.StartedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.ErrorMessage,
			&i.DevicePlatform,
			&i.DeviceModel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSafetySettings = `-- name: GetUserSafetySettings :one
SELECT id, user_id, anonymous_session_id, device_id, notifications_enabled, notification_alert_types, notification_alert_radius_mins, notification_report_types, notification_report_radius_mins, location_sharing_enabled, location_history_enabled, profile_visibility, anonymous_reports, show_online_status, auto_alerts_enabled, danger_zones_enabled, time_based_alerts_enabled, high_risk_start_time, high_risk_end_time, night_mode_enabled, night_mode_start_time, night_mode_end_time, created_at, updated_at FROM user_safety_settings
WHERE user_id = $1::UUID
LIMIT 1
`

// Retorna configurações de um usuário autenticado
func (q *Queries) GetUserSafetySettings(ctx context.Context, userID uuid.UUID) (UserSafetySetting, error) {
	row := q.db.QueryRowContext(ctx, getUserSafetySettings, userID)
	var i UserSafetySetting
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AnonymousSessionID,
		&i.DeviceID,
		&i.NotificationsEnabled,
		pq.Array(&i.NotificationAlertTypes),
		&i.NotificationAlertRadiusMins,
		pq.Array(&i.NotificationReportTypes),
		&i.NotificationReportRadiusMins,
		&i.LocationSharingEnabled,
		&i.LocationHistoryEnabled,
		&i.ProfileVisibility,
		&i.AnonymousReports,
		&i.ShowOnlineStatus,
		&i.AutoAlertsEnabled,
		&i.DangerZonesEnabled,
		&i.TimeBasedAlertsEnabled,
		&i.HighRiskStartTime,
		&i.HighRiskEndTime,
		&i.NightModeEnabled,
		&i.NightModeStartTime,
		&i.NightModeEndTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const markAnonymousSessionAsMigrated = `-- name: MarkAnonymousSessionAsMigrated :exec
UPDATE anonymous_sessions
SET migrated_to_user_id = $1::UUID,
    migrated_at = NOW(),
    is_active = false,
    updated_at = NOW()
WHERE id = $2::UUID
`

type MarkAnonymousSessionAsMigratedParams struct {
	UserID             uuid.UUID `json:"user_id"`
	AnonymousSessionID uuid.UUID `json:"anonymous_session_id"`
}

// Marca uma sessão anônima como migrada
func (q *Queries) MarkAnonymousSessionAsMigrated(ctx context.Context, arg MarkAnonymousSessionAsMigratedParams) error {
	_, err := q.db.ExecContext(ctx, markAnonymousSessionAsMigrated, arg.UserID, arg.AnonymousSessionID)
	return err
}

const markMigrationCompleted = `-- name: MarkMigrationCompleted :exec
UPDATE anonymous_user_migrations
SET completed_at = NOW()
WHERE id = $1::UUID
`

// Marca uma migração como concluída
func (q *Queries) MarkMigrationCompleted(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, markMigrationCompleted, id)
	return err
}

const markMigrationFailed = `-- name: MarkMigrationFailed :exec
UPDATE anonymous_user_migrations
SET failed_at = NOW(),
    error_message = $1
WHERE id = $2::UUID
`

type MarkMigrationFailedParams struct {
	ErrorMessage sql.NullString `json:"error_message"`
	ID           uuid.UUID      `json:"id"`
}

// Marca uma migração como falha
func (q *Queries) MarkMigrationFailed(ctx context.Context, arg MarkMigrationFailedParams) error {
	_, err := q.db.ExecContext(ctx, markMigrationFailed, arg.ErrorMessage, arg.ID)
	return err
}

const mergeSafetySettings = `-- name: MergeSafetySettings :exec
UPDATE user_safety_settings auth
SET 
    notifications_enabled = COALESCE(anon.notifications_enabled, auth.notifications_enabled),
    notification_alert_types = COALESCE(anon.notification_alert_types, auth.notification_alert_types),
    notification_alert_radius_mins = COALESCE(anon.notification_alert_radius_mins, auth.notification_alert_radius_mins),
    notification_report_types = COALESCE(anon.notification_report_types, auth.notification_report_types),
    notification_report_radius_mins = COALESCE(anon.notification_report_radius_mins, auth.notification_report_radius_mins),
    location_sharing_enabled = COALESCE(anon.location_sharing_enabled, auth.location_sharing_enabled),
    location_history_enabled = COALESCE(anon.location_history_enabled, auth.location_history_enabled),
    profile_visibility = COALESCE(anon.profile_visibility, auth.profile_visibility),
    anonymous_reports = COALESCE(anon.anonymous_reports, auth.anonymous_reports),
    show_online_status = COALESCE(anon.show_online_status, auth.show_online_status),
    auto_alerts_enabled = COALESCE(anon.auto_alerts_enabled, auth.auto_alerts_enabled),
    danger_zones_enabled = COALESCE(anon.danger_zones_enabled, auth.danger_zones_enabled),
    time_based_alerts_enabled = COALESCE(anon.time_based_alerts_enabled, auth.time_based_alerts_enabled),
    high_risk_start_time = COALESCE(anon.high_risk_start_time, auth.high_risk_start_time),
    high_risk_end_time = COALESCE(anon.high_risk_end_time, auth.high_risk_end_time),
    night_mode_enabled = COALESCE(anon.night_mode_enabled, auth.night_mode_enabled),
    night_mode_start_time = COALESCE(anon.night_mode_start_time, auth.night_mode_start_time),
    night_mode_end_time = COALESCE(anon.night_mode_end_time, auth.night_mode_end_time),
    updated_at = NOW()
FROM user_safety_settings anon
WHERE auth.user_id = $1::UUID
  AND anon.anonymous_session_id = $2::UUID
  AND anon.updated_at > auth.updated_at
`

type MergeSafetySettingsParams struct {
	UserID             uuid.UUID `json:"user_id"`
	AnonymousSessionID uuid.UUID `json:"anonymous_session_id"`
}

// Merge inteligente: prioriza configurações anônimas se mais recentes
func (q *Queries) MergeSafetySettings(ctx context.Context, arg MergeSafetySettingsParams) error {
	_, err := q.db.ExecContext(ctx, mergeSafetySettings, arg.UserID, arg.AnonymousSessionID)
	return err
}

const migrateAlertsToUser = `-- name: MigrateAlertsToUser :execrows

UPDATE alerts
SET created_by = $1::UUID,
    anonymous_session_id = NULL,
    device_id = NULL
WHERE anonymous_session_id = $2::UUID
  AND created_by IS NULL
`

type MigrateAlertsToUserParams struct {
	UserID             uuid.UUID `json:"user_id"`
	AnonymousSessionID uuid.UUID `json:"anonymous_session_id"`
}

// ============================================================================
// SQLC QUERIES FOR ANONYMOUS TO AUTHENTICATED USER MIGRATION
// ============================================================================
// File: internal/adapter/repository/postgres/queries/anonymous_migration.sql
// Purpose: Type-safe queries for migrating anonymous user data
// ============================================================================
// Migra todos os alertas de uma sessão anônima para um usuário autenticado
func (q *Queries) MigrateAlertsToUser(ctx context.Context, arg MigrateAlertsToUserParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, migrateAlertsToUser, arg.UserID, arg.AnonymousSessionID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const migrateLocationSharingsToUser = `-- name: MigrateLocationSharingsToUser :execrows
UPDATE location_sharings
SET user_id = $1::UUID,
    anonymous_session_id = NULL,
    device_id = NULL
WHERE anonymous_session_id = $2::UUID
  AND user_id IS NULL
`

type MigrateLocationSharingsToUserParams struct {
	UserID             uuid.UUID `json:"user_id"`
	AnonymousSessionID uuid.UUID `json:"anonymous_session_id"`
}

// Migra compartilhamentos de localização de uma sessão anônima para um usuário autenticado
func (q *Queries) MigrateLocationSharingsToUser(ctx context.Context, arg MigrateLocationSharingsToUserParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, migrateLocationSharingsToUser, arg.UserID, arg.AnonymousSessionID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const migrateSafetySettingsToUser = `-- name: MigrateSafetySettingsToUser :execrows
UPDATE user_safety_settings
SET user_id = $1::UUID,
    anonymous_session_id = NULL,
    device_id = NULL
WHERE anonymous_session_id = $2::UUID
  AND user_id IS NULL
  AND NOT EXISTS (
    SELECT 1 FROM user_safety_settings
    WHERE user_id = $1::UUID
  )
`

type MigrateSafetySettingsToUserParams struct {
	UserID             uuid.UUID `json:"user_id"`
	AnonymousSessionID uuid.UUID `json:"anonymous_session_id"`
}

// Migra configurações de segurança de uma sessão anônima para um usuário autenticado
// NOTA: Apenas migra se o usuário NÃO tiver configurações
func (q *Queries) MigrateSafetySettingsToUser(ctx context.Context, arg MigrateSafetySettingsToUserParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, migrateSafetySettingsToUser, arg.UserID, arg.AnonymousSessionID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const migrateSubscriptionsToUser = `-- name: MigrateSubscriptionsToUser :execrows
UPDATE alert_subscriptions
SET user_id = $1::UUID,
    anonymous_session_id = NULL,
    device_id = NULL
WHERE anonymous_session_id = $2::UUID
  AND user_id IS NULL
`

type MigrateSubscriptionsToUserParams struct {
	UserID             uuid.UUID `json:"user_id"`
	AnonymousSessionID uuid.UUID `json:"anonymous_session_id"`
}

// Migra todas as subscrições de uma sessão anônima para um usuário autenticado
func (q *Queries) MigrateSubscriptionsToUser(ctx context.Context, arg MigrateSubscriptionsToUserParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, migrateSubscriptionsToUser, arg.UserID, arg.AnonymousSessionID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const rollbackAlertsToAnonymous = `-- name: RollbackAlertsToAnonymous :execrows

UPDATE alerts
SET created_by = NULL,
    anonymous_session_id = $1::UUID,
    device_id = $2
WHERE created_by = $3::UUID
  AND created_at >= $4::TIMESTAMP
`

type RollbackAlertsToAnonymousParams struct {
	AnonymousSessionID uuid.UUID      `json:"anonymous_session_id"`
	DeviceID           sql.NullString `json:"device_id"`
	UserID             uuid.UUID      `json:"user_id"`
	MigrationStartedAt time.Time      `json:"migration_started_at"`
}

// ============================================================================
// QUERIES FOR ROLLBACK (Error Recovery)
// ============================================================================
// Reverte migração de alertas (rollback)
func (q *Queries) RollbackAlertsToAnonymous(ctx context.Context, arg RollbackAlertsToAnonymousParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, rollbackAlertsToAnonymous,
		arg.AnonymousSessionID,
		arg.DeviceID,
		arg.UserID,
		arg.MigrationStartedAt,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const rollbackAnonymousSessionMigration = `-- name: RollbackAnonymousSessionMigration :exec
UPDATE anonymous_sessions
SET migrated_to_user_id = NULL,
    migrated_at = NULL,
    is_active = true,
    updated_at = NOW()
WHERE id = $1::UUID
`

// Reverte status de migração da sessão anônima
func (q *Queries) RollbackAnonymousSessionMigration(ctx context.Context, anonymousSessionID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, rollbackAnonymousSessionMigration, anonymousSessionID)
	return err
}

const rollbackSubscriptionsToAnonymous = `-- name: RollbackSubscriptionsToAnonymous :execrows
UPDATE alert_subscriptions
SET user_id = NULL,
    anonymous_session_id = $1::UUID,
    device_id = $2
WHERE user_id = $3::UUID
  AND subscribed_at >= $4::TIMESTAMP
`

type RollbackSubscriptionsToAnonymousParams struct {
	AnonymousSessionID uuid.UUID      `json:"anonymous_session_id"`
	DeviceID           sql.NullString `json:"device_id"`
	UserID             uuid.UUID      `json:"user_id"`
	MigrationStartedAt time.Time      `json:"migration_started_at"`
}

// Reverte migração de subscrições (rollback)
func (q *Queries) RollbackSubscriptionsToAnonymous(ctx context.Context, arg RollbackSubscriptionsToAnonymousParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, rollbackSubscriptionsToAnonymous,
		arg.AnonymousSessionID,
		arg.DeviceID,
		arg.UserID,
		arg.MigrationStartedAt,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateMigrationCounters = `-- name: UpdateMigrationCounters :exec
UPDATE anonymous_user_migrations
SET alerts_migrated = $1,
    subscriptions_migrated = $2,
    settings_migrated = $3::BOOLEAN,
    location_sharings_migrated = $4
WHERE id = $5::UUID
`

type UpdateMigrationCountersParams struct {
	AlertsMigrated           int32     `json:"alerts_migrated"`
	SubscriptionsMigrated    int32     `json:"subscriptions_migrated"`
	SettingsMigrated         bool      `json:"settings_migrated"`
	LocationSharingsMigrated int32     `json:"location_sharings_migrated"`
	ID                       uuid.UUID `json:"id"`
}

// Atualiza os contadores de uma migração
func (q *Queries) UpdateMigrationCounters(ctx context.Context, arg UpdateMigrationCountersParams) error {
	_, err := q.db.ExecContext(ctx, updateMigrationCounters,
		arg.AlertsMigrated,
		arg.SubscriptionsMigrated,
		arg.SettingsMigrated,
		arg.LocationSharingsMigrated,
		arg.ID,
	)
	return err
}
