// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: location_sharings.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createLocationSharing = `-- name: CreateLocationSharing :exec
INSERT INTO location_sharings (
    id, user_id, anonymous_session_id, device_id, owner_name,
    token, latitude, longitude, duration_minutes, expires_at, last_updated_at, is_active
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
`

type CreateLocationSharingParams struct {
	ID                 uuid.UUID      `json:"id"`
	UserID             uuid.NullUUID  `json:"user_id"`
	AnonymousSessionID uuid.NullUUID  `json:"anonymous_session_id"`
	DeviceID           sql.NullString `json:"device_id"`
	OwnerName          sql.NullString `json:"owner_name"`
	Token              string         `json:"token"`
	Latitude           float64        `json:"latitude"`
	Longitude          float64        `json:"longitude"`
	DurationMinutes    int32          `json:"duration_minutes"`
	ExpiresAt          time.Time      `json:"expires_at"`
	LastUpdatedAt      time.Time      `json:"last_updated_at"`
	IsActive           bool           `json:"is_active"`
}

func (q *Queries) CreateLocationSharing(ctx context.Context, arg CreateLocationSharingParams) error {
	_, err := q.db.ExecContext(ctx, createLocationSharing,
		arg.ID,
		arg.UserID,
		arg.AnonymousSessionID,
		arg.DeviceID,
		arg.OwnerName,
		arg.Token,
		arg.Latitude,
		arg.Longitude,
		arg.DurationMinutes,
		arg.ExpiresAt,
		arg.LastUpdatedAt,
		arg.IsActive,
	)
	return err
}

const deactivateExpiredLocationSharings = `-- name: DeactivateExpiredLocationSharings :exec
UPDATE location_sharings
SET is_active = false, updated_at = NOW()
WHERE expires_at < $1 AND is_active = true
`

func (q *Queries) DeactivateExpiredLocationSharings(ctx context.Context, expiresAt time.Time) error {
	_, err := q.db.ExecContext(ctx, deactivateExpiredLocationSharings, expiresAt)
	return err
}

const deleteLocationSharing = `-- name: DeleteLocationSharing :exec
DELETE FROM location_sharings
WHERE id = $1
`

func (q *Queries) DeleteLocationSharing(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteLocationSharing, id)
	return err
}

const getLocationSharingByID = `-- name: GetLocationSharingByID :one
SELECT id, user_id, anonymous_session_id, device_id, owner_name, token, latitude, longitude, duration_minutes, expires_at, last_updated_at, is_active, created_at, updated_at FROM location_sharings
WHERE id = $1
`

func (q *Queries) GetLocationSharingByID(ctx context.Context, id uuid.UUID) (LocationSharing, error) {
	row := q.db.QueryRowContext(ctx, getLocationSharingByID, id)
	var i LocationSharing
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AnonymousSessionID,
		&i.DeviceID,
		&i.OwnerName,
		&i.Token,
		&i.Latitude,
		&i.Longitude,
		&i.DurationMinutes,
		&i.ExpiresAt,
		&i.LastUpdatedAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLocationSharingByToken = `-- name: GetLocationSharingByToken :one
SELECT id, user_id, anonymous_session_id, device_id, owner_name, token, latitude, longitude, duration_minutes, expires_at, last_updated_at, is_active, created_at, updated_at FROM location_sharings
WHERE token = $1
`

func (q *Queries) GetLocationSharingByToken(ctx context.Context, token string) (LocationSharing, error) {
	row := q.db.QueryRowContext(ctx, getLocationSharingByToken, token)
	var i LocationSharing
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AnonymousSessionID,
		&i.DeviceID,
		&i.OwnerName,
		&i.Token,
		&i.Latitude,
		&i.Longitude,
		&i.DurationMinutes,
		&i.ExpiresAt,
		&i.LastUpdatedAt,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listActiveLocationSharingsByDeviceID = `-- name: ListActiveLocationSharingsByDeviceID :many
SELECT id, user_id, anonymous_session_id, device_id, owner_name, token, latitude, longitude, duration_minutes, expires_at, last_updated_at, is_active, created_at, updated_at FROM location_sharings
WHERE device_id = $1 AND is_active = true
ORDER BY created_at DESC
`

func (q *Queries) ListActiveLocationSharingsByDeviceID(ctx context.Context, deviceID sql.NullString) ([]LocationSharing, error) {
	rows, err := q.db.QueryContext(ctx, listActiveLocationSharingsByDeviceID, deviceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LocationSharing{}
	for rows.Next() {
		var i LocationSharing
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AnonymousSessionID,
			&i.DeviceID,
			&i.OwnerName,
			&i.Token,
			&i.Latitude,
			&i.Longitude,
			&i.DurationMinutes,
			&i.ExpiresAt,
			&i.LastUpdatedAt,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveLocationSharingsByUserID = `-- name: ListActiveLocationSharingsByUserID :many
SELECT id, user_id, anonymous_session_id, device_id, owner_name, token, latitude, longitude, duration_minutes, expires_at, last_updated_at, is_active, created_at, updated_at FROM location_sharings
WHERE user_id = $1 AND is_active = true
ORDER BY created_at DESC
`

func (q *Queries) ListActiveLocationSharingsByUserID(ctx context.Context, userID uuid.NullUUID) ([]LocationSharing, error) {
	rows, err := q.db.QueryContext(ctx, listActiveLocationSharingsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LocationSharing{}
	for rows.Next() {
		var i LocationSharing
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AnonymousSessionID,
			&i.DeviceID,
			&i.OwnerName,
			&i.Token,
			&i.Latitude,
			&i.Longitude,
			&i.DurationMinutes,
			&i.ExpiresAt,
			&i.LastUpdatedAt,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllLocationSharings = `-- name: ListAllLocationSharings :many
SELECT id, user_id, anonymous_session_id, device_id, owner_name, token, latitude, longitude, duration_minutes, expires_at, last_updated_at, is_active, created_at, updated_at FROM location_sharings
ORDER BY created_at DESC
`

func (q *Queries) ListAllLocationSharings(ctx context.Context) ([]LocationSharing, error) {
	rows, err := q.db.QueryContext(ctx, listAllLocationSharings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LocationSharing{}
	for rows.Next() {
		var i LocationSharing
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AnonymousSessionID,
			&i.DeviceID,
			&i.OwnerName,
			&i.Token,
			&i.Latitude,
			&i.Longitude,
			&i.DurationMinutes,
			&i.ExpiresAt,
			&i.LastUpdatedAt,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLocationSharing = `-- name: UpdateLocationSharing :exec
UPDATE location_sharings
SET 
    latitude = $2,
    longitude = $3,
    last_updated_at = $4,
    is_active = $5,
    updated_at = $6
WHERE id = $1
`

type UpdateLocationSharingParams struct {
	ID            uuid.UUID `json:"id"`
	Latitude      float64   `json:"latitude"`
	Longitude     float64   `json:"longitude"`
	LastUpdatedAt time.Time `json:"last_updated_at"`
	IsActive      bool      `json:"is_active"`
	UpdatedAt     time.Time `json:"updated_at"`
}

func (q *Queries) UpdateLocationSharing(ctx context.Context, arg UpdateLocationSharingParams) error {
	_, err := q.db.ExecContext(ctx, updateLocationSharing,
		arg.ID,
		arg.Latitude,
		arg.Longitude,
		arg.LastUpdatedAt,
		arg.IsActive,
		arg.UpdatedAt,
	)
	return err
}
